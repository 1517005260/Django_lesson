# *lesson 9*
thrift服务

本节课注意环境：`pip install channels-redis==3.4.1 `

可以参考linux基础课的thrift服务：[地址](https://github.com/1517005260/thrift_lesson)

[讲义](https://www.acwing.com/file_system/file/content/whole/index/content/3435229/)

别人的[笔记](https://www.acwing.com/activity/content/code/content/2360556/)

## *lesson 9.1*
本节课实现匹配系统

### 理论

1.thrift的功能远不止于游戏匹配。比如写一个外卖系统，有关骑手和消费者、商家的匹配，也可以用thrift写；一个打车系统，也可以匹配司机和乘客。<br>
除此之外，oj的评测功能也可以用thrift写。
###### 凡是不能阻塞、需要第三方服务的独立功能（额外进程），都可以用thrift实现（进程间的通信）
==> 延展django的功能

2.之前的匹配逻辑：暴力筛选空房间 ==> 会导致高手和菜鸟匹配在一起，影响游戏体验<br>
解决：采用积分匹配法而不是先到先得法   ==> 两种匹配方式的最大区别：时间。前者有延时性，后者有即时性<br>
所以不能沿用之前的逻辑，否则会导致：服务器本机或本模块会等待半个小时（很长时间，即阻塞）等才会返回给前端信息<br>
所以一种可行的解决方案是：向服务器发送请求后，我们可以干其他事情，等服务器匹配成功后再通知我们之后再回来继续<br>
==> 采用分离服务器法：即把原来的server功能拆分为`server + 匹配系统`  当用户提交匹配请求时，server接收请求，并转移给匹配系统，server直接向用户返回结果。这个新的模块（匹配系统），就是thrift

#### 预备知识：进程/线程
| 特性     | 进程                                                                 | 线程                                                                                     | 比喻          |
|----------|----------------------------------------------------------------------|------------------------------------------------------------------------------------------|---------------|
| 定义     | 操作系统分配资源和调度的基本单位。包含执行程序所需的所有资源。        | 进程中的实际执行单位，操作系统调度的最小单位。共享进程的资源，但拥有自己的执行堆栈等。 | 国王（进程）有多个领主（线程）。 |
| 独立性   | 每个进程有独立的地址空间，互不干扰。                                 | 线程共享同一进程的资源和地址空间，易于通信但需要同步。                                   | 领主共享国王的资源。 |
| 资源分配 | 是资源分配的单位，拥有独立的内存等资源。                             | 不单独拥有资源，使用进程提供的资源。                                                     | 领地是国王分配的。 |
| 通信     | 需要IPC机制（消息队列、共享内存、管道等）进行进程间通信。                                          | 可直接读写共享的数据，但需同步机制避免冲突。                                             | 领主间的通信比向国王汇报更直接。 |
| 创建销毁 | 开销较大，因为涉及更多的资源和状态。                                 | 开销较小，因为共享进程的资源。                                                           | 创建领主比建立一个新王国要简单。 |
| 用途     | 执行一个程序或应用。                                                | 实现程序内部的并发操作。                                                                 | 管理国家的不同部分。 |


#### 消息队列简介

消息队列（Message Queue）是一种应用程序之间的通信方法，允许系统的不同部分独立地发送和接收信息，实现异步通信。这种机制帮助解决数据传输问题，实现松耦合、负载平衡和缓冲功能，增强系统的可扩展性和健壮性。

##### 核心概念和功能

| 概念         | 描述                                                         |
|--------------|-------------------------------------------------------------|
| 生产者和消费者 | 生产者发送消息，消费者接收消息。通常是独立的系统或应用组件。   |
| 队列         | 存储消息的容器，消息按发送顺序排列，遵循先进先出（FIFO）原则。 |
| 异步通信     | 生产者和消费者异步发送和接收消息，无需等待对方处理完成。       |
| 缓冲和削峰   | 作为缓冲区管理请求速率，减轻高峰压力。                         |
| 可靠性和持久性 | 消息持久化存储，确保系统故障时消息不丢失。                     |
| 解耦         | 提供中间层解耦生产者和消费者，支持独立扩展和修改。             |
| 消息模式     | 支持多种消息传递模式，如点对点、发布/订阅等。                   |

##### 应用实例

电商平台订单处理流程是消息队列应用的一个典型例子，包括订单系统、支付系统、库存系统和物流系统，通过消息队列进行高效稳定的异步通信和处理。


| 步骤       | 系统       | 功能描述                                             | 消息队列作用                  |
|------------|------------|-----------------------------------------------------|-------------------------------|
| 1. 接收订单 | 订单系统   | 用户下单后生成新订单                                 | 将订单详情发送到消息队列中    |
| 2. 支付处理 | 支付系统   | 处理支付请求，验证支付信息、扣款                     | 从队列接收订单并处理，结果发送到下一个队列 |
| 3. 库存管理 | 库存系统   | 根据订单减少相应商品的库存量                         | 从队列接收支付成功的订单并处理，结果发送到下一个队列 |
| 4. 订单配送 | 物流系统   | 安排发货和配送                                       | 从队列接收库存更新后的订单并进行配送 |

##### 消息队列的好处：

- **异步处理**：各环节独立进行，提高流程效率。【生产者专注于发送请求，消费者专注于解决请求】
- **解耦系统**：降低系统间耦合度，便于维护和扩展。
- **提高稳定性**：保证消息持久化，确保信息不丢失。
- **负载平衡**：根据处理能力动态调整消息分发，避免瓶颈。


##### 常见实现

包括RabbitMQ、Apache Kafka、Amazon SQS、Google Cloud Pub/Sub等。



3.thrift就是在原来的服务器之外，新开一个进程，独立于原server。thrift方便这两个进程通信（ip地址+端口号）<br>
匹配系统的进程会时刻关注匹配池（ex.链表、数组等），一旦匹配成功，就会通知server，server再通知客户端<br>
由于本项目的匹配系统计算量不大（参考linux基础课），所以没有必要用第二个服务器，直接在本服务器拆分模块即可

4.匹配系统支持的操作（python实现）
- 每1s在匹配池中进行一次匹配
- 虽然新玩家会随时加进来，但是我们要保证每次执行匹配的时候链表都是固定的，方便我们写程序  ==>  匹配系统内部多线程：匹配+接收新玩家
- 异步通信：每次匹配完之后，在下次匹配前，我们要将所有新请求统一加到匹配池里。    ==> 涉及到阻塞、缓存与消息队列：在匹配进行时要缓存所有的新请求（消息队列），即每次有新请求均加到消息队列里，然后server直接返回。每次匹配时先查看消息队列是否不空，如果不空的话就每次将消息队列里的请求统一拿出来
- 在以上的过程中，原server相当于是client，匹配系统相当于是server

### 实现  【匹配核心功能+通信的两条有向边】
1.实现server端匹配系统--此时game是client，match_server是server
- 先`pip install thrift`
- 显然`match_system`和`game`相互独立，所以二者应该在同一个文件夹下
- 创建后记得`__init__.py`
- 子文件`thrift`存储thrift配置，`src`实现具体逻辑
- 配置好`thrift`后，在`src`下`thrift --gen py ../thrift/match.thrift`创建项目,可以把自动生成的`gen-py`改名为`match_server`
- 在`match_server`下创建主文件`main.py`
- 有关`main.py`的python-server配置，可直接参考[官网](https://thrift.apache.org/tutorial/py.html)然后作修改，详见代码

2.实现client端（game）请求功能
- 多人模式的匹配请求客户端位于`/game/consumers/multiplayer/index.py`
- 当一名玩家被创建出来时，需要将其加到匹配池里  ==> 即事件`create_player`触发时，向匹配系统请求，所以我们重写一下`create_player`函数
- 原逻辑：玩家被创建后立即进入一个房间，然后被广播房间内所有其他人的信息  ==> 现逻辑：玩家被创建后 `game -> match_server` 立即发送请求，匹配成功后再广播
- 客户端代码可以参考linux基础课的代码

3.实现匹配系统向game返回结果的功能（利用到了`channel_name`这个参数）
- 当使用Django Channels建立WebSocket连接（WSS协议）时，系统会自动为每个连接分配一个唯一的`channel_name`
- 首先修改`/django_lesson/asgi.py`的配置
- 然后我们发现在`index.py`下的函数都是异步模式，所以在通信`main.py`时要引入`async_to_sync`  【保持编程的一致性】
- redis存匹配信息
- 房间名格式`room-a.uuid-b.uuid-c.uuid` ==> 方便`cache.keys('*a.uuid*')`直接查找a的房间号

4.扩充数据库  -- 附带score
- 改完之后记得更新数据库
- 每次新增玩家时查询他的分数  方法比较神奇，在函数里定义函数
- 数据库的操作都是同步的，所以要`sync_to_async`适应`index.py`

#### 总结流程
1.玩家点击多人模式，通过wss协议向服务器请求，服务器收到请求后路由到`create_player`函数，预备建立thrift链接。匹配系统通过`./main.py`初始化

2.服务器在`create_player`下进行一系列通信预备操作，并通过`client.add_player()`向匹配系统发送请求

3.匹配系统在`if __name__ == '__main__'`下`server.serve()`接收请求

4.`MatchHandler`下的`add_player()`将新加入的玩家放入消息队列

5.`worker()`不断处理请求，进行匹配

6.匹配成功后，先把当前房间的玩家拉入群组`async_to_sync(channel_layer.group_add)(room_name, p.channel_name)`，之后通过`'type':"group_send_event"`指定当消息通过群组广播时，应该触发Consumers的哪个方法

7.之后过程同之前wss