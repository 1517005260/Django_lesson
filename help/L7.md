# *lesson7*
接下来两次课实现联机对战

[讲义](https://www.acwing.com/file_system/file/content/whole/index/content/3357332/)

## *lesson 7.1*
别人的[笔记](https://www.acwing.com/activity/content/code/content/2306978/)

1.统一度量衡 让所有玩家、不同设备的地图都是16:9的
- 每个屏幕的瓶颈都是最短的那个边
- 一并解决L4的遗留问题：进入游戏后地图已随菜单窗口固定而不会随现在的窗口变化  => 用相对位置而不是绝对位置
- 逻辑：`解决屏幕大小可以随视窗大小变化`->`解决渲染canvas忽白忽暗的问题+css`->`解决元素相对变化的问题（以scale为基准）`
- 注意：游戏的逻辑全部都是相对于视窗大大小的，而渲染时会根据当前视窗转化比例
- 注意：每次更新视窗大小时都要重新获取当前的标准，否则游戏内的对象只会和第一次的视窗绑定

2.增加联机对战模式（多人模式）
- 在menu的监听事件中补充多人模式的逻辑，并在show函数中区分单人和多人的逻辑
- 我们还会发现，原先的`is_me`是个bool值，只有两种情况判定，但是引入多人模式之后，我们需要区分：`me / robot / enemy`三个，所以需要修改`is_me`为字符串

3.铺垫结束，如何联机？
- 同步事件操作1-生成玩家事件：通过服务器实现  -- ex.现在已经有两名玩家在地图中，现在第三名玩家加入。此时操作：`3告诉服务器自己来了`->`服务器通知1和2有3来了`->`服务器通知3地图有1，2`
- 同步事件操作2-移动玩家事件  --ex.玩家3移动：`3通知服务器自己移动了`->`服务器接到通知后通知1，2`->`1,2接收后将3渲染到指定位置`
- 同步事件操作3-发射技能事件  --ex.玩家3发射火球：`3通知服务器自己发射了火球`->`服务器广播这个事件`->`1,2接收后渲染出3向指定方向发射技能的事件`
- 同步事件操作4-攻击事件  如果判定攻击事件放在服务器，那么由于网络有延迟，可能存在3动了一会之后1，2视角中3才动。这样就会导致判定问题：我到底有没有击中敌人？  ==> 解决方案：在本地的视窗中进行攻击判断。优：玩家体验佳 / 劣：容易作弊  +  以主动发起进攻的视窗为主导：如果3中发现击中了1，但是1由于网络延迟发现自己没被击中，但是系统优先以3为主，判定1受击

4.`http => 单向协议`（只有客户端request后才能有服务器response） / `websocket=>双向协议` （也支持了服务器向客户端request）
- 在3中，我们发现client <==> server ，需要双向协议，以前我们使用的http无法满足我们的需求
- 像http有加密版协议https一样，ws也有加密版wss
- django对wss协议的支持：[django_channel](https://www.acwing.com/blog/content/12692/)
- 由于联机游戏对延迟要求高，所以在服务器端对玩家的血量等信息维护的数据库读写效率要高 => redis
- 配置时，ws中的routing、consumers相当于http中的url、view
- 启动wss服务（类似uwsgi） ：`daphne -b 0.0.0.0 -p 5015 django_lesson.asgi:application`  django_lesson记得换名字
- 最后在前端建立与后端wss的连接，可以在playground文件下新建一个socket文件夹专门维护

4.5 同步、异步[笔记](https://www.acwing.com/solution/content/84013/)

5.重头戏：编写同步函数（上）