# *lesson7*
接下来两次课实现联机对战

[讲义](https://www.acwing.com/file_system/file/content/whole/index/content/3357332/)

## *lesson 7.1*
别人的[笔记](https://www.acwing.com/activity/content/code/content/2306978/)

1.统一度量衡 让所有玩家、不同设备的地图都是16:9的
- 每个屏幕的瓶颈都是最短的那个边
- 一并解决L4的遗留问题：进入游戏后地图已随菜单窗口固定而不会随现在的窗口变化  => 用相对位置而不是绝对位置
- 逻辑：`解决屏幕大小可以随视窗大小变化`->`解决渲染canvas忽白忽暗的问题+css`->`解决元素相对变化的问题（以scale为基准）`
- 注意：游戏的逻辑全部都是相对于视窗大大小的，而渲染时会根据当前视窗转化比例
- 注意：每次更新视窗大小时都要重新获取当前的标准，否则游戏内的对象只会和第一次的视窗绑定

2.增加联机对战模式（多人模式）
- 在menu的监听事件中补充多人模式的逻辑，并在show函数中区分单人和多人的逻辑
- 我们还会发现，原先的`is_me`是个bool值，只有两种情况判定，但是引入多人模式之后，我们需要区分：`me / robot / enemy`三个，所以需要修改`is_me`为字符串

3.铺垫结束，如何联机？
- 同步事件操作1-生成玩家事件：通过服务器实现  -- ex.现在已经有两名玩家在地图中，现在第三名玩家加入。此时操作：`3告诉服务器自己来了`->`服务器通知1和2有3来了`->`服务器通知3地图有1，2`
- 同步事件操作2-移动玩家事件  --ex.玩家3移动：`3通知服务器自己移动了`->`服务器接到通知后通知1，2`->`1,2接收后将3渲染到指定位置`
- 同步事件操作3-发射技能事件  --ex.玩家3发射火球：`3通知服务器自己发射了火球`->`服务器广播这个事件`->`1,2接收后渲染出3向指定方向发射技能的事件`
- 同步事件操作4-攻击事件  如果判定攻击事件放在服务器，那么由于网络有延迟，可能存在3动了一会之后1，2视角中3才动。这样就会导致判定问题：我到底有没有击中敌人？  <br>
==> 解决方案：在本地的视窗中进行攻击判断。优：玩家体验佳 / 劣：容易作弊  +  以主动发起进攻的视窗为主导：如果3中发现击中了1，但是1由于网络延迟发现自己没被击中，但是系统优先以3为主，判定1受击

4.`http => 单向协议`（只有客户端request后才能有服务器response） / `websocket=>双向协议` （也支持了服务器向客户端request）

WebSocket技术使得可以实时更新游戏状态，确保所有玩家的游戏视图保持一致，从而提供了流畅和互动的多玩家游戏体验。

- 在3中，我们发现client <==> server ，需要双向协议，以前我们使用的http无法满足我们的需求
- 像http有加密版协议https一样，ws也有加密版wss
- django对wss协议的支持：[django_channel](https://www.acwing.com/blog/content/12692/)
- 由于联机游戏对延迟要求高，所以在服务器端对玩家的血量等信息维护的数据库读写效率要高 => redis
- 配置时，ws中的routing、consumers相当于http中的url、view
- 启动wss服务（类似uwsgi） ：`daphne -b 0.0.0.0 -p 5015 django_lesson.asgi:application`  django_lesson记得换名字
- 最后在前端建立与后端wss的连接，可以在playground文件下新建一个socket文件夹专门维护

4.5 同步、异步[笔记](https://www.acwing.com/solution/content/84013/)
- 同步就是我必须等待上一个任务完成了，才能去下一个；异步就是我开始了任务1，但是1的结果还要一会，那么我可以去干任务2，提高效率
- 例子讲解详见index代码

5.重头戏：编写同步函数（上） `routings`+`consumers`+`js`
- 可以发现，不仅是player，而且火球、粒子特效等都需要一个唯一id（uuid）来辨识，以达成火球击中一名玩家后，在每个客户端都能看见火球消失的效果<br>
  ===> 我们要知道我们同步了*谁*  ,  这个辨别谁的uuid可以存到基类game_object里  ， 并且我们以通信的方式保持uuid和创建这个uuid的窗口一致

5.1 同步create_player事件
- 每个窗口只有自己 -> 每个窗口还有其他人
- 首先，我们需要在服务器端存下每局对战的信息（redis），其中，room_0代表第0局，room_1代表第一局，以此类推。我们可以设定每局游戏上限3人方便调试
- 由于我们目前没有实现匹配机制，我们可以用暴力叠加法，即第0间满了再看第一间
- 注意所有的传递参数都要一致，比如event是“create_player”就一直是这个，不要更改，否则会报错

### 总结流程
即：新用户加入游戏，前端通过WebSocket连接发送加入游戏的请求到服务器，服务器处理请求，创建或更新游戏状态，并将游戏更新广播给所有相关客户端，其他客户端接收到游戏状态更新后，更新各自的界面以反映最新的游戏状态

1.用户点击多人模式（在前端中的playground类中体现） --> 

2.记录用户的uuid并且试图建立ws连接 -->

3.在MultiPlayerSocket类中用WebSocket类建立连接（地址和routing一致）--> 
- 连接建立后触发服务器端的connect函数，开始分配房间
- 异步操作：分配房间成功后等待服务器同意websocket连接。
- 异步操作：向加进来的玩家广播已有玩家信息
- 异步操作：将新的WebSocket连接加入到代表该房间的通信组

4.MultiPlayerSocket被初始化，并启动receive()监听服务器的请求 -->

5.playground中成功连接后调用send_create_player，向服务器发送玩家信息 -->
- 服务器receive收到前端请求，并异步执行create_player
- create_player将新进来的玩家加到redis里，并异步向其他玩家广播新玩家的信息
- 服务器group_create_player向前端发送信息

6.前端receive收到服务器消息
- 其中，我们通过uuid让服务器不再向新玩家发消息
- 其次，将这个新玩家加到其他玩家的地图里，并标记为“enemy”

## *lesson 7.2*
补丁
- 本节课删除了各种调试用的console.log信息
- 为acapp的“退出键”增加了api，使得它不再是摆设

5.编写同步函数（下）
- [讲义](https://www.acwing.com/blog/content/12739/)
- 别人的[笔记](https://www.acwing.com/solution/content/85280/)

5.2 同步move_to事件 三步走：触发+前端+后端
- 前端同之前一样要在MultiPlayerSocket类里实现send_event和receive_event函数
- 后端也可以模仿create_player
- 分析：为什么别的视窗可以看见自己动了？<br>
流程：自己移动=>本窗口的人在移动（监听事件鼠标右键）==> 剩下这个房间的人怎么动？通过mode判断为多人模式，通过send_move_to向服务器发送信息==>服务器调用move_to函数向所有所有人群发uuid这名玩家移动的消息==>每个窗口都会在前端接收到信息==>调用uuid的移动函数

5.3 同步shoot_fireball事件
- 由于发射的火球要消失，所以像gameobjects一样用一个数组维护。谁发的火球，这个火球就存到他的数组里，并且我们需要获取这个火球的uuid，像move_to一样同步这个发出去的火球  ==> 新增了火球数组记得ondestroy掉，destroy只会删除gameobjects里的元素，我们需要删除干净
- fireball中的update函数稍显臃肿，我们需要拆分一下

5.4 为了解决延迟的问题，我们采用谁发射，谁主导判定的机制，以此同步attack事件